

## trade_return_monitor.cpp 中锁延迟的 Cycle 级分析

### 前提假设

| 参数 | 值 | 说明 |
|------|-----|------|
| CPU | Intel Xeon Skylake / Cascade Lake | 典型 Linux 服务器 |
| 频率 | ~3.0 GHz | 1 cycle ≈ 0.33ns |
| L1 hit | 4-5 cycles | |
| L2 hit | 12-14 cycles | |
| L3 hit | 30-40 cycles | |
| DRAM | 150-300 cycles | |
| `lock cmpxchg`（无竞争，缓存行在 M/E 态） | 18-22 cycles | mutex lock 核心指令 |
| `lock cmpxchg`（缓存行需跨核传输） | 40-75 cycles | MESI I→E 转换 |

---

### 一、锁清单

文件中共 3 处 `mutex_` 获取：

| # | 位置 | 调用频率 | 竞争场景 |
|---|------|---------|---------|
| ①  | `on_match()` 业务锁 | **每笔成交推送** | 热路径 |
| ②  | `snapshot_0917()` 循环内每行锁 | 启动时102次 | 冷路径，但可能与①竞争 |
| ③  | `snapshot_0917()` 末尾读count | 启动时1次 | 可忽略 |

**关键路径是 ①**，下面重点分析。

---

### 二、`on_match()` 锁的 Cycle 计算

#### 2.1 mutex lock/unlock 本身开销

```
std::lock_guard<mutex> 构造 (lock):
  lock cmpxchg [futex_word], 0→1     ~20 cycles   // CAS 原子操作
  + implicit MFENCE (lock prefix)     ~0 cycles    // lock 前缀自带 full barrier
  
~lock_guard 析构 (unlock):
  lock xchg / atomic store            ~10 cycles   // 释放锁
  + check waiter count                ~3 cycles    // 分支预测命中
  
mutex 纯开销 = 20 + 10 + 3 ≈ 33 cycles
```

#### 2.2 临界区内操作逐行估算

以 **`same_price_second_sale`** 路径（触发跟单的最长路径）为例：

```
操作                                               cycles       说明
─────────────────────────────────────────────────────────────────────────
① printed_keys_.find(key)                          30-50       uint64 哈希 + 桶查找
   ├─ hash<uint64_t>(key)                          5-8         整数哈希，1-2条指令
   └─ bucket lookup + compare                      25-42       L1/L2 命中时
   
② recorded_order_ids_.find(order_id)               30-50       int64 哈希 + 桶查找
   ├─ hash<int64_t>                                5-8         
   └─ bucket lookup                                25-42       
   → 未命中，走 else 分支

③ recorded_by_stock_.find(stock_key)               60-120      string key 哈希
   ├─ hash<string>("000505")                       20-40       6字节 FNV/murmur
   ├─ bucket lookup                                20-40       指针追踪
   └─ string compare                               20-40       memcmp 6 bytes
   
④ fabs(price - recorded.order_price) < 1e-6       3-5         FP subtract + compare

⑤ followup_sent_stocks_.find(stock_key)            60-120      同③，string哈希查找

⑥ followup_sent_stocks_.insert(stock_key)          80-200      
   ├─ hash 计算                                    20-40       
   ├─ bucket 查找                                  20-40       
   ├─ string copy (SSO 6 bytes)                    10-20       小字符串优化，栈上
   └─ node 分配 (malloc)                           30-100      allocator 开销
   
⑦ printed_keys_.insert(key)                        50-120      
   ├─ hash<uint64_t>                               5-8         
   ├─ bucket 查找                                  20-40       
   └─ node 分配                                    25-72       
   
─────────────────────────────────────────────────────────────────────────
临界区内操作合计                                    313-665 cycles
```

#### 2.3 总延迟

```
on_match() 单次锁总延迟 = mutex开销 + 临界区操作

最佳情况（全部 L1 命中，无竞争）:
  33 + 313 = 346 cycles ≈ 115 ns @ 3GHz

典型情况（L2 命中为主）:
  33 + 450 = 483 cycles ≈ 161 ns @ 3GHz

最差情况（有 L3 miss + 容器扩容）:
  33 + 665 = 698 cycles ≈ 233 ns @ 3GHz
```

---

### 三、竞争场景的额外开销

如果 `on_match()` 和 `snapshot_0917()` 同时争抢 `mutex_`（理论上因为 `snapshot_ready_` 的存在不会发生）：

```
跨核缓存行传输:
  mutex futex_word 从 Core A (snapshot线程) → Core B (worker线程)
  MESI: M→I→E 转换                                +40-75 cycles

如果锁被持有需要自旋:
  glibc adaptive spin（默认约100次）                +200-400 cycles

如果自旋失败进入 futex syscall:
  syscall 入口                                      +150-300 cycles
  内核调度 context switch                           +2000-5000 cycles
  唤醒后 syscall 返回                               +150-300 cycles
  ──────────────────────────────────────────────
  竞争下总增加                                      +2500-6000 cycles
```

**但实际不会发生**：`on_match()` 入口有 `if (!snapshot_ready_.load()) return;`，快照未完成前成交消息直接返回。

---

### 四、汇总

| 场景 | 锁延迟 (cycles) | 延迟 (ns @3GHz) |
|------|:---------------:|:---------------:|
| **无竞争 - 最佳** | **~346** | **~115** |
| **无竞争 - 典型** | **~483** | **~161** |
| **无竞争 - 最差** | **~698** | **~233** |
| 有竞争 - 自旋成功 | ~900 | ~300 |
| 有竞争 - futex 睡眠 | ~3000-6000 | ~1000-2000 |

### 五、瓶颈在哪

锁本身的 `lock cmpxchg` 只占 **33 cycles（~7%）**，真正的延迟大头是**临界区内的哈希表操作**（~93%），尤其是：
- `string` 类型 key 的哈希计算和比较（③⑤⑥）
- `unordered_set/map` 的内存分配（⑥⑦ 的 `insert`）

如果要优化，方向应该是**缩短临界区**而非更换锁，比如把 `printed_keys_.insert` 和 `followup_sent_stocks_.insert` 移到锁外（用 double-check 或 lock-free set 替代）。